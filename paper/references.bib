@InProceedings{hipspec,
author="Claessen, Koen
and Johansson, Moa
and Ros{\'e}n, Dan
and Smallbone, Nicholas",
editor="Bonacina, Maria Paola",
title="Automating Inductive Proofs Using Theory Exploration",
booktitle="Automated Deduction -- CADE-24",
year="2013",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="392--406",
abstract="HipSpec is a system for automatically deriving and proving properties about functional programs. It uses a novel approach, combining theory exploration, counterexample testing and inductive theorem proving. HipSpec automatically generates a set of equational theorems about the available recursive functions of a program. These equational properties make up an algebraic specification for the program and can in addition be used as a background theory for proving additional user-stated properties. Experimental results are encouraging: HipSpec compares favourably to other inductive theorem provers and theory exploration systems.",
isbn="978-3-642-38574-2"
}

@inproceedings{fingertrees_new,
author = {Claessen, Koen},
title = {Finger Trees Explained Anew, and Slightly Simplified (Functional Pearl)},
year = {2020},
isbn = {9781450380508},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3406088.3409026},
doi = {10.1145/3406088.3409026},
abstract = {We explicitly motivate the subtle intricacies of Hinze and Paterson's Finger Tree datastructure, by step-wise refining a naive implementation. The result is a new explanation of how Finger Trees work and why they have the particular structure they have, and also a small simplification of the original implementation.},
booktitle = {Proceedings of the 13th ACM SIGPLAN International Symposium on Haskell},
pages = {31–38},
numpages = {8},
keywords = {finger trees, datastructures, functional pearl, amortized complexity},
location = {Virtual Event, USA},
series = {Haskell 2020}
}

@inproceedings{proving_for_all,
author = {Claessen, Koen},
title = {Finger Trees Explained Anew, and Slightly Simplified (Functional Pearl)},
year = {2020},
isbn = {9781450380508},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3406088.3409026},
doi = {10.1145/3406088.3409026},
abstract = {We explicitly motivate the subtle intricacies of Hinze and Paterson's Finger Tree datastructure, by step-wise refining a naive implementation. The result is a new explanation of how Finger Trees work and why they have the particular structure they have, and also a small simplification of the original implementation.},
booktitle = {Proceedings of the 13th ACM SIGPLAN International Symposium on Haskell},
pages = {31–38},
numpages = {8},
keywords = {finger trees, datastructures, functional pearl, amortized complexity},
location = {Virtual Event, USA},
series = {Haskell 2020}
}

@article{fingertrees,
author = {Hinze, Ralf and Paterson, Ross},
title = {Finger Trees: A Simple General-Purpose Data Structure},
year = {2006},
issue_date = {March 2006},
publisher = {Cambridge University Press},
address = {USA},
volume = {16},
number = {2},
issn = {0956-7968},
url = {https://doi.org/10.1017/S0956796805005769},
doi = {10.1017/S0956796805005769},
abstract = {We introduce 2-3 finger trees, a functional representation of persistent sequences supporting access to the ends in amortized constant time, and concatenation and splitting in time logarithmic in the size of the smaller piece. Representations achieving these bounds have appeared previously, but 2-3 finger trees are much simpler, as are the operations on them. Further, by defining the split operation in a general form, we obtain a general purpose data structure that can serve as a sequence, priority queue, search tree, priority search queue and more.},
journal = {J. Funct. Program.},
month = mar,
pages = {197–217},
numpages = {21}
}
