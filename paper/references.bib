@InProceedings{hipspec,
author="Claessen, Koen
and Johansson, Moa
and Ros{\'e}n, Dan
and Smallbone, Nicholas",
editor="Bonacina, Maria Paola",
title="Automating Inductive Proofs Using Theory Exploration",
booktitle="Automated Deduction -- CADE-24",
year="2013",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="392--406",
abstract="HipSpec is a system for automatically deriving and proving properties about functional programs. It uses a novel approach, combining theory exploration, counterexample testing and inductive theorem proving. HipSpec automatically generates a set of equational theorems about the available recursive functions of a program. These equational properties make up an algebraic specification for the program and can in addition be used as a background theory for proving additional user-stated properties. Experimental results are encouraging: HipSpec compares favourably to other inductive theorem provers and theory exploration systems.",
isbn="978-3-642-38574-2"
}

@book{isabelle,
author="Nipkow, Tobias
and Wenzel, Markus
and Paulson, Lawrence C.",
title="Isabelle/HOL: A Proof Assistant for Higher-Order Logic",
year="2002",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
abstract="This book is a tutorial on how to use the theorem prover Isabelle/HOL as a specification and verification system. Isabelle is a generic system for implementing logical formalisms, and Isabelle/HOL is the specialization of Isabelle for HOL,which abbreviates Higher-Order Logic. We introduce HOL step by step following the equation HOL = Functional Programming+ Logic.",
isbn="978-3-540-45949-1",
doi="10.1007/3-540-45949-9",
url="https://doi.org/10.1007/3-540-45949-9"
}

@InBook{lean,
author="de Moura, Leonardo
and Kong, Soonho
and Avigad, Jeremy
and van Doorn, Floris
and von Raumer, Jakob",
editor="Felty, Amy P.
and Middeldorp, Aart",
title="The Lean Theorem Prover (System Description)",
booktitle="Automated Deduction - CADE-25",
year="2015",
publisher="Springer International Publishing",
address="Cham",
pages="378--388",
abstract="Lean is a new open source theorem prover being developed at Microsoft Research and Carnegie Mellon University, with a small trusted kernel based on dependent type theory. It aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specified axiomatic proofs. Lean is an ongoing and long-term effort, but it already provides many useful components, integrated development environments, and a rich API which can be used to embed it into other systems. It is currently being used to formalize category theory, homotopy type theory, and abstract algebra. We describe the project goals, system architecture, and main features, and we discuss applications and continuing work.",
isbn="978-3-319-21401-6"
}

@phdthesis{liquidhaskell,
author="Niki Vazou",
title="Liquid Haskell: Haskell as a Theorem Prover",
school="University of California",
address="San Diego, CA",
year="2016"
}

@inproceedings{refinement_types,
author = {Freeman, Tim and Pfenning, Frank},
title = {Refinement Types for ML},
year = {1991},
isbn = {0897914287},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/113445.113468},
doi = {10.1145/113445.113468},
booktitle = {Proceedings of the ACM SIGPLAN 1991 Conference on Programming Language Design and Implementation},
pages = {268–277},
numpages = {10},
location = {Toronto, Ontario, Canada},
series = {PLDI '91}
}

@article{reflection,
author = {Vazou, Niki and Tondwalkar, Anish and Choudhury, Vikraman and Scott, Ryan G. and Newton, Ryan R. and Wadler, Philip and Jhala, Ranjit},
title = {Refinement Reflection: Complete Verification with SMT},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158141},
doi = {10.1145/3158141},
abstract = {We introduce Refinement Reflection, a new framework for building SMT-based deductive verifiers. The key idea is to reflect the code implementing a user-defined function into the function’s (output) refinement type. As a consequence, at uses of the function, the function definition is instantiated in the SMT logic in a precise fashion that permits decidable verification. Reflection allows the user to write equational proofs of programs just by writing other programs using pattern-matching and recursion to perform case-splitting and induction. Thus, via the propositions-as-types principle, we show that reflection permits the specification of arbitrary functional correctness properties. Finally, we introduce a proof-search algorithm called Proof by Logical Evaluation that uses techniques from model checking and abstract interpretation, to completely automate equational reasoning. We have implemented reflection in Liquid Haskell and used it to verify that the widely used instances of the Monoid, Applicative, Functor, and Monad typeclasses actually satisfy key algebraic laws required to make the clients safe, and have used reflection to build the first library that actually verifies assumptions about associativity and ordering that are crucial for safe deterministic parallelism.},
journal = {Proc. ACM Program. Lang.},
month = dec,
articleno = {53},
numpages = {31},
keywords = {verification, theorem proving, refinement types, Haskell}
}

@article{10.1145/113446.113468,
author = {Freeman, Tim and Pfenning, Frank},
title = {Refinement Types for ML},
year = {1991},
issue_date = {June 1991},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {26},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/113446.113468},
doi = {10.1145/113446.113468},
journal = {SIGPLAN Not.},
month = may,
pages = {268–277},
numpages = {10}
}


@inproceedings{fingertrees_new,
author = {Claessen, Koen},
title = {Finger Trees Explained Anew, and Slightly Simplified (Functional Pearl)},
year = {2020},
isbn = {9781450380508},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3406088.3409026},
doi = {10.1145/3406088.3409026},
abstract = {We explicitly motivate the subtle intricacies of Hinze and Paterson's Finger Tree datastructure, by step-wise refining a naive implementation. The result is a new explanation of how Finger Trees work and why they have the particular structure they have, and also a small simplification of the original implementation.},
booktitle = {Proceedings of the 13th ACM SIGPLAN International Symposium on Haskell},
pages = {31–38},
numpages = {8},
keywords = {finger trees, datastructures, functional pearl, amortized complexity},
location = {Virtual Event, USA},
series = {Haskell 2020}
}

@inproceedings{tpfa,
author = {Vazou, Niki and Breitner, Joachim and Kunkel, Rose and Van Horn, David and Hutton, Graham},
title = {Theorem Proving for All: Equational Reasoning in Liquid Haskell (Functional Pearl)},
year = {2018},
isbn = {9781450358354},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3242744.3242756},
doi = {10.1145/3242744.3242756},
abstract = {Equational reasoning is one of the key features of pure functional languages such as Haskell. To date, however, such reasoning always took place externally to Haskell, either manually on paper, or mechanised in a theorem prover. This article shows how equational reasoning can be performed directly and seamlessly within Haskell itself, and be checked using Liquid Haskell. In particular, language learners --- to whom external theorem provers are out of reach --- can benefit from having their proofs mechanically checked. Concretely, we show how the equational proofs and derivations from Graham's textbook can be recast as proofs in Haskell (spoiler: they look essentially the same).},
booktitle = {Proceedings of the 11th ACM SIGPLAN International Symposium on Haskell},
pages = {132–144},
numpages = {13},
keywords = {Liquid Haskell, Haskell, program optimization, equational reasoning, theorem proving},
location = {St. Louis, MO, USA},
series = {Haskell 2018}
}

@article{fingertrees,
author = {Hinze, Ralf and Paterson, Ross},
title = {Finger Trees: A Simple General-Purpose Data Structure},
year = {2006},
issue_date = {March 2006},
publisher = {Cambridge University Press},
address = {USA},
volume = {16},
number = {2},
issn = {0956-7968},
url = {https://doi.org/10.1017/S0956796805005769},
doi = {10.1017/S0956796805005769},
abstract = {We introduce 2-3 finger trees, a functional representation of persistent sequences supporting access to the ends in amortized constant time, and concatenation and splitting in time logarithmic in the size of the smaller piece. Representations achieving these bounds have appeared previously, but 2-3 finger trees are much simpler, as are the operations on them. Further, by defining the split operation in a general form, we obtain a general purpose data structure that can serve as a sequence, priority queue, search tree, priority search queue and more.},
journal = {J. Funct. Program.},
month = mar,
pages = {197–217},
numpages = {21}
}
