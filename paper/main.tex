\documentclass[sigplan,screen]{acmart}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2021}
\acmYear{2021}
\acmDOI{tbd}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Haskell '21]{the 14th ACM SIGPLAN International Haskell Symposium}{August 26--27, 2021}{Virtual Event}
%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%  June 03--05, 2018, Woodstock, NY}
%\acmPrice{15.00}
%\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Liquid Amortization - Proving amortized complexity with LiquidHaskell (Functional Pearl)}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Jan van Brügge}
\email{jan.van-bruegge@tum.de}
%\orcid{1234-5678-9012}
\affiliation{%
  \institution{Technical University Munich}
  \streetaddress{Arcisstraße 21}
  \city{Munich}
  \state{Bavaria}
  \country{Germany}
  \postcode{80333}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
%\renewcommand{\shortauthors}{Trovato and Tobin, et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
TODO
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003752.10003809.10010031</concept_id>
       <concept_desc>Theory of computation~Data structures design and analysis</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
       <concept_desc>Software and its engineering~Functional languages</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10010940.10010992.10010998.10010999</concept_id>
       <concept_desc>Software and its engineering~Software verification</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Data structures design and analysis}
\ccsdesc[500]{Software and its engineering~Functional languages}
\ccsdesc[500]{Software and its engineering~Software verification}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{datastructures, LiquidHaskell, amortized complexity, finger trees, theorem proving, functional pearl}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

Motivation:
\begin{itemize}
\item{Formal proofs for properties of data structures are getting more common}
\item{Most of the time proof is done in other language}
\item{Needs a translation step, either manual or programmatic}
\item{Might have errors in translation}
\item{Might not support all features of implementation language}
\item{Thus needs encoding}
\item{Hard to reconnect proofs back to the actual implementation}
\end{itemize}

Solution:
\begin{itemize}
\item{LiquidHaskell \cite{liquidhaskell} is a refinement type \cite{refinement_types} checker for Haskell}
\item{Can be used as a theorem prover \cite{tpfa}}
\item{Directly provide proofs in Haskell, skipping the translation step}
\end{itemize}

Contributions:
\begin{itemize}
\item{Explain how amortized complexity works}
\item{How to prove amortized complexity}
\item{Show with case studies of core Haskell data structures how to apply this}
\end{itemize}

\section{Amortized complexity}

\begin{itemize}
\item{Worst case is often too pessimistic}
\item{Idea: spread out expensive operations over multiple cheap ones}
\item{Usually only talks about sequence of operations without sharing}
\item{Formalization: Physicist's method}
\end{itemize}

\section{LiquidHaskell for theorem proving}

\begin{itemize}
\item{Uses refinement types}
\item{Refinments are solved by external SMT solver (z3)}
\item{With the refinement one can define proof combinators}
\item{Use equational reasoning and induction to prove interesing properties}
\end{itemize}

\section{Case studies}

\begin{itemize}
\item{encode requirements of potential as type synonym}
\end{itemize}

\subsection{Stack with Multipop}

\begin{itemize}
\item{definition of data structure and operations}
\item{worst case of push and multipop is O(1) and O(n)}
\item{but every item we pop was pushed at some point}
\item{define potential as height of stack}
\item{refine all functions to the logic level \cite{reflection}}
\item{guess constant factor}
\item{prove base case and adjust constant}
\item{use induction for complex case}
\end{itemize}

\subsection{Finger Tree}

\begin{itemize}
\item{originally described in \cite{fingertrees}}
\item{definition of finger tree}
\item{code is copy pased from the containers package}
\item{in contrast to \cite{fingertrees_new} four constructors and different append function}
\item{slightly modified because LiquidHaskell does not work great with type classes}
\item{mention polymorphic recursion that is not supported in Lean \cite{lean} and Isabelle/HOL \cite{isabelle}}
\item{potential of a finger tree}
\end{itemize}

\subsubsection{Cons and Snoc}

\begin{itemize}
\item{cons and snoc are very similar, see snoc code in appendix}
\item{definition of the cons function}
\item{definition of the consT function}
\item{step by step proof of amortized complexity}
\end{itemize}

\subsubsection{Append}\label{sec:append}

\begin{itemize}
\item{same as worst case, but potential may differ}
\item{definition of append as mutually recursive functions}
\item{no automatic termination metric, track termination across recursion}
\item{generates a lot of constraints > 3000, takes long to typecheck}
\item{defining the timing function would generate over 8000 constraints}
\item{proving with logarithms is not easy, but potentiation makes it easier}
\item{sadly not really possible to do as every step takes forever to typecheck}
\end{itemize}

\section{Limitations of this approach}

\subsection{Definition of the timing function}

\begin{itemize}
\item{without changing the system under test, we have to manually create a timing function}
\item{manual approach might lead to errors}
\item{Idea 1: factor out recursion and use same recursion for implementation and timing}
\item{Idea 2: use template Haskell to generate timing function}
\end{itemize}

\subsection{LiquidHaskell for verification}

\begin{itemize}
\item{support for type classes is not great at the moment}
\item{as seen in section~\ref{sec:append}, more complicated pattern matches lead to combinatorial explosion}
\item{might be possible to be smarter when generating constraints}
\item{no direct support for rationals make non-linear proofs involving division harder}
\item{several performance related options like --no-termination, --diff, --fast, did not make a difference for type checking}
\end{itemize}

\section{Conclusion}

\begin{itemize}
\item{Get more confidence that your implementation matches the theoretical expectations}
\item{Easy to apply for simple complexities like O(1) or O(n)}
\item{Harder with O(log n) because the SMT prover/LiquidHaskell is not quite there yet}
\end{itemize}

%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
%\begin{acks}
%\end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

%%
%% If your work has an appendix, this is the place to put it.
\appendix

\end{document}
\endinput
